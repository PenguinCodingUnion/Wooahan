{"ast":null,"code":"import { AnimationClip, AnimationMixer, Euler, Matrix4, Quaternion, QuaternionKeyframeTrack, SkeletonHelper, Vector2, Vector3, VectorKeyframeTrack } from 'three';\nfunction retarget(target, source) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const pos = new Vector3(),\n    quat = new Quaternion(),\n    scale = new Vector3(),\n    bindBoneMatrix = new Matrix4(),\n    relativeMatrix = new Matrix4(),\n    globalMatrix = new Matrix4();\n  options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n  options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n  options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n  options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n  options.hip = options.hip !== undefined ? options.hip : 'hip';\n  options.names = options.names || {};\n  const sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source),\n    bones = target.isObject3D ? target.skeleton.bones : getBones(target);\n  let bindBones, bone, name, boneTo, bonesPosition;\n\n  // reset bones\n\n  if (target.isObject3D) {\n    target.skeleton.pose();\n  } else {\n    options.useTargetMatrix = true;\n    options.preserveMatrix = false;\n  }\n  if (options.preservePosition) {\n    bonesPosition = [];\n    for (let i = 0; i < bones.length; i++) {\n      bonesPosition.push(bones[i].position.clone());\n    }\n  }\n  if (options.preserveMatrix) {\n    // reset matrix\n\n    target.updateMatrixWorld();\n    target.matrixWorld.identity();\n\n    // reset children matrix\n\n    for (let i = 0; i < target.children.length; ++i) {\n      target.children[i].updateMatrixWorld(true);\n    }\n  }\n  if (options.offsets) {\n    bindBones = [];\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      if (options.offsets[name]) {\n        bone.matrix.multiply(options.offsets[name]);\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n      bindBones.push(bone.matrixWorld.clone());\n    }\n  }\n  for (let i = 0; i < bones.length; ++i) {\n    bone = bones[i];\n    name = options.names[bone.name] || bone.name;\n    boneTo = getBoneByName(name, sourceBones);\n    globalMatrix.copy(bone.matrixWorld);\n    if (boneTo) {\n      boneTo.updateMatrixWorld();\n      if (options.useTargetMatrix) {\n        relativeMatrix.copy(boneTo.matrixWorld);\n      } else {\n        relativeMatrix.copy(target.matrixWorld).invert();\n        relativeMatrix.multiply(boneTo.matrixWorld);\n      }\n\n      // ignore scale to extract rotation\n\n      scale.setFromMatrixScale(relativeMatrix);\n      relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));\n\n      // apply to global matrix\n\n      globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n      if (target.isObject3D) {\n        const boneIndex = bones.indexOf(bone),\n          wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n        globalMatrix.multiply(wBindMatrix);\n      }\n      globalMatrix.copyPosition(relativeMatrix);\n    }\n    if (bone.parent && bone.parent.isBone) {\n      bone.matrix.copy(bone.parent.matrixWorld).invert();\n      bone.matrix.multiply(globalMatrix);\n    } else {\n      bone.matrix.copy(globalMatrix);\n    }\n    if (options.preserveHipPosition && name === options.hip) {\n      bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n    }\n    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n    bone.updateMatrixWorld();\n  }\n  if (options.preservePosition) {\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      if (name !== options.hip) {\n        bone.position.copy(bonesPosition[i]);\n      }\n    }\n  }\n  if (options.preserveMatrix) {\n    // restore matrix\n\n    target.updateMatrixWorld(true);\n  }\n}\nfunction retargetClip(target, source, clip) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n  options.fps = options.fps !== undefined ? options.fps : 30;\n  options.names = options.names || [];\n  if (!source.isObject3D) {\n    source = getHelperFromSkeleton(source);\n  }\n  const numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n    delta = 1 / options.fps,\n    convertedTracks = [],\n    mixer = new AnimationMixer(source),\n    bones = getBones(target.skeleton),\n    boneDatas = [];\n  let positionOffset, bone, boneTo, boneData, name;\n  mixer.clipAction(clip).play();\n  mixer.update(0);\n  source.updateMatrixWorld();\n  for (let i = 0; i < numFrames; ++i) {\n    const time = i * delta;\n    retarget(target, source, options);\n    for (let j = 0; j < bones.length; ++j) {\n      name = options.names[bones[j].name] || bones[j].name;\n      boneTo = getBoneByName(name, source.skeleton);\n      if (boneTo) {\n        bone = bones[j];\n        boneData = boneDatas[j] = boneDatas[j] || {\n          bone: bone\n        };\n        if (options.hip === name) {\n          if (!boneData.pos) {\n            boneData.pos = {\n              times: new Float32Array(numFrames + 1),\n              values: new Float32Array((numFrames + 1) * 3)\n            };\n          }\n          if (options.useFirstFramePosition) {\n            if (i === 0) {\n              positionOffset = bone.position.clone();\n            }\n            bone.position.sub(positionOffset);\n          }\n          boneData.pos.times[i] = time;\n          bone.position.toArray(boneData.pos.values, i * 3);\n        }\n        if (!boneData.quat) {\n          // `numFrames + 1` accomodate final keyframe\n          boneData.quat = {\n            times: new Float32Array(numFrames + 1),\n            values: new Float32Array((numFrames + 1) * 4)\n          };\n        }\n        boneData.quat.times[i] = time;\n        bone.quaternion.toArray(boneData.quat.values, i * 4);\n      }\n    }\n\n    // check for final keyframe\n    if (i === numFrames - 1) {\n      mixer.update(Math.max(clip.duration - mixer.time, 0));\n    } else {\n      mixer.update(delta);\n    }\n    source.updateMatrixWorld();\n  }\n  retarget(target, source, options);\n\n  // add boneData at final keyframe\n  for (let j = 0; j < boneDatas.length; ++j) {\n    boneData = boneDatas[j];\n    if (boneData) {\n      if (boneData.pos) {\n        boneData.pos.times[numFrames] = clip.duration;\n        bone.position.toArray(boneData.pos.values, numFrames * 3);\n      }\n      if (boneData.quat) {\n        boneData.quat.times[numFrames] = clip.duration;\n        bone.position.toArray(boneData.quat.values, numFrames * 4);\n      }\n    }\n  }\n  for (let i = 0; i < boneDatas.length; ++i) {\n    boneData = boneDatas[i];\n    if (boneData) {\n      if (boneData.pos) {\n        convertedTracks.push(new VectorKeyframeTrack('.bones[' + boneData.bone.name + '].position', boneData.pos.times, boneData.pos.values));\n      }\n      convertedTracks.push(new QuaternionKeyframeTrack('.bones[' + boneData.bone.name + '].quaternion', boneData.quat.times, boneData.quat.values));\n    }\n  }\n  mixer.uncacheAction(clip);\n  return new AnimationClip(clip.name, -1, convertedTracks);\n}\nfunction getHelperFromSkeleton(skeleton) {\n  const source = new SkeletonHelper(skeleton.bones[0]);\n  source.skeleton = skeleton;\n  return source;\n}\nfunction getSkeletonOffsets(target, source) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const targetParentPos = new Vector3(),\n    targetPos = new Vector3(),\n    sourceParentPos = new Vector3(),\n    sourcePos = new Vector3(),\n    targetDir = new Vector2(),\n    sourceDir = new Vector2();\n  options.hip = options.hip !== undefined ? options.hip : 'hip';\n  options.names = options.names || {};\n  if (!source.isObject3D) {\n    source = getHelperFromSkeleton(source);\n  }\n  const nameKeys = Object.keys(options.names),\n    nameValues = Object.values(options.names),\n    sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source),\n    bones = target.isObject3D ? target.skeleton.bones : getBones(target),\n    offsets = [];\n  let bone, boneTo, name, i;\n  target.skeleton.pose();\n  for (i = 0; i < bones.length; ++i) {\n    bone = bones[i];\n    name = options.names[bone.name] || bone.name;\n    boneTo = getBoneByName(name, sourceBones);\n    if (boneTo && name !== options.hip) {\n      const boneParent = getNearestBone(bone.parent, nameKeys),\n        boneToParent = getNearestBone(boneTo.parent, nameValues);\n      boneParent.updateMatrixWorld();\n      boneToParent.updateMatrixWorld();\n      targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);\n      targetPos.setFromMatrixPosition(bone.matrixWorld);\n      sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);\n      sourcePos.setFromMatrixPosition(boneTo.matrixWorld);\n      targetDir.subVectors(new Vector2(targetPos.x, targetPos.y), new Vector2(targetParentPos.x, targetParentPos.y)).normalize();\n      sourceDir.subVectors(new Vector2(sourcePos.x, sourcePos.y), new Vector2(sourceParentPos.x, sourceParentPos.y)).normalize();\n      const laterialAngle = targetDir.angle() - sourceDir.angle();\n      const offset = new Matrix4().makeRotationFromEuler(new Euler(0, 0, laterialAngle));\n      bone.matrix.multiply(offset);\n      bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n      bone.updateMatrixWorld();\n      offsets[name] = offset;\n    }\n  }\n  return offsets;\n}\nfunction renameBones(skeleton, names) {\n  const bones = getBones(skeleton);\n  for (let i = 0; i < bones.length; ++i) {\n    const bone = bones[i];\n    if (names[bone.name]) {\n      bone.name = names[bone.name];\n    }\n  }\n  return this;\n}\nfunction getBones(skeleton) {\n  return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n}\nfunction getBoneByName(name, skeleton) {\n  for (let i = 0, bones = getBones(skeleton); i < bones.length; i++) {\n    if (name === bones[i].name) return bones[i];\n  }\n}\nfunction getNearestBone(bone, names) {\n  while (bone.isBone) {\n    if (names.indexOf(bone.name) !== -1) {\n      return bone;\n    }\n    bone = bone.parent;\n  }\n}\nfunction findBoneTrackData(name, tracks) {\n  const regexp = /\\[(.*)\\]\\.(.*)/,\n    result = {\n      name: name\n    };\n  for (let i = 0; i < tracks.length; ++i) {\n    // 1 is track name\n    // 2 is track type\n    const trackData = regexp.exec(tracks[i].name);\n    if (trackData && name === trackData[1]) {\n      result[trackData[2]] = i;\n    }\n  }\n  return result;\n}\nfunction getEqualsBonesNames(skeleton, targetSkeleton) {\n  const sourceBones = getBones(skeleton),\n    targetBones = getBones(targetSkeleton),\n    bones = [];\n  search: for (let i = 0; i < sourceBones.length; i++) {\n    const boneName = sourceBones[i].name;\n    for (let j = 0; j < targetBones.length; j++) {\n      if (boneName === targetBones[j].name) {\n        bones.push(boneName);\n        continue search;\n      }\n    }\n  }\n  return bones;\n}\nfunction clone(source) {\n  const sourceLookup = new Map();\n  const cloneLookup = new Map();\n  const clone = source.clone();\n  parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n    sourceLookup.set(clonedNode, sourceNode);\n    cloneLookup.set(sourceNode, clonedNode);\n  });\n  clone.traverse(function (node) {\n    if (!node.isSkinnedMesh) return;\n    const clonedMesh = node;\n    const sourceMesh = sourceLookup.get(node);\n    const sourceBones = sourceMesh.skeleton.bones;\n    clonedMesh.skeleton = sourceMesh.skeleton.clone();\n    clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n    clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n      return cloneLookup.get(bone);\n    });\n    clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n  });\n  return clone;\n}\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\nexport { retarget, retargetClip, getHelperFromSkeleton, getSkeletonOffsets, renameBones, getBones, getBoneByName, getNearestBone, findBoneTrackData, getEqualsBonesNames, clone };","map":{"version":3,"names":["AnimationClip","AnimationMixer","Euler","Matrix4","Quaternion","QuaternionKeyframeTrack","SkeletonHelper","Vector2","Vector3","VectorKeyframeTrack","retarget","target","source","options","arguments","length","undefined","pos","quat","scale","bindBoneMatrix","relativeMatrix","globalMatrix","preserveMatrix","preservePosition","preserveHipPosition","useTargetMatrix","hip","names","sourceBones","isObject3D","skeleton","bones","getBones","bindBones","bone","name","boneTo","bonesPosition","pose","i","push","position","clone","updateMatrixWorld","matrixWorld","identity","children","offsets","matrix","multiply","decompose","quaternion","getBoneByName","copy","invert","setFromMatrixScale","set","x","y","z","makeRotationFromQuaternion","setFromRotationMatrix","boneIndex","indexOf","wBindMatrix","boneInverses","copyPosition","parent","isBone","setPosition","retargetClip","clip","useFirstFramePosition","fps","getHelperFromSkeleton","numFrames","Math","round","duration","delta","convertedTracks","mixer","boneDatas","positionOffset","boneData","clipAction","play","update","time","j","times","Float32Array","values","sub","toArray","max","uncacheAction","getSkeletonOffsets","targetParentPos","targetPos","sourceParentPos","sourcePos","targetDir","sourceDir","nameKeys","Object","keys","nameValues","boneParent","getNearestBone","boneToParent","setFromMatrixPosition","subVectors","normalize","laterialAngle","angle","offset","makeRotationFromEuler","renameBones","Array","isArray","findBoneTrackData","tracks","regexp","result","trackData","exec","getEqualsBonesNames","targetSkeleton","targetBones","search","boneName","sourceLookup","Map","cloneLookup","parallelTraverse","sourceNode","clonedNode","traverse","node","isSkinnedMesh","clonedMesh","sourceMesh","get","bindMatrix","map","bind","a","b","callback"],"sources":["C:/Users/SSAFY/Documents/S08P31B206/front/node_modules/three/examples/jsm/utils/SkeletonUtils.js"],"sourcesContent":["import {\n\tAnimationClip,\n\tAnimationMixer,\n\tEuler,\n\tMatrix4,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tSkeletonHelper,\n\tVector2,\n\tVector3,\n\tVectorKeyframeTrack\n} from 'three';\n\n\nfunction retarget( target, source, options = {} ) {\n\n\tconst pos = new Vector3(),\n\t\tquat = new Quaternion(),\n\t\tscale = new Vector3(),\n\t\tbindBoneMatrix = new Matrix4(),\n\t\trelativeMatrix = new Matrix4(),\n\t\tglobalMatrix = new Matrix4();\n\n\toptions.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n\toptions.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n\toptions.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n\toptions.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n\toptions.hip = options.hip !== undefined ? options.hip : 'hip';\n\toptions.names = options.names || {};\n\n\tconst sourceBones = source.isObject3D ? source.skeleton.bones : getBones( source ),\n\t\tbones = target.isObject3D ? target.skeleton.bones : getBones( target );\n\n\tlet bindBones,\n\t\tbone, name, boneTo,\n\t\tbonesPosition;\n\n\t// reset bones\n\n\tif ( target.isObject3D ) {\n\n\t\ttarget.skeleton.pose();\n\n\t} else {\n\n\t\toptions.useTargetMatrix = true;\n\t\toptions.preserveMatrix = false;\n\n\t}\n\n\tif ( options.preservePosition ) {\n\n\t\tbonesPosition = [];\n\n\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\tbonesPosition.push( bones[ i ].position.clone() );\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveMatrix ) {\n\n\t\t// reset matrix\n\n\t\ttarget.updateMatrixWorld();\n\n\t\ttarget.matrixWorld.identity();\n\n\t\t// reset children matrix\n\n\t\tfor ( let i = 0; i < target.children.length; ++ i ) {\n\n\t\t\ttarget.children[ i ].updateMatrixWorld( true );\n\n\t\t}\n\n\t}\n\n\tif ( options.offsets ) {\n\n\t\tbindBones = [];\n\n\t\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\t\tbone = bones[ i ];\n\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\tif ( options.offsets[ name ] ) {\n\n\t\t\t\tbone.matrix.multiply( options.offsets[ name ] );\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\tbone.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t\tbindBones.push( bone.matrixWorld.clone() );\n\n\t\t}\n\n\t}\n\n\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\tbone = bones[ i ];\n\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\tboneTo = getBoneByName( name, sourceBones );\n\n\t\tglobalMatrix.copy( bone.matrixWorld );\n\n\t\tif ( boneTo ) {\n\n\t\t\tboneTo.updateMatrixWorld();\n\n\t\t\tif ( options.useTargetMatrix ) {\n\n\t\t\t\trelativeMatrix.copy( boneTo.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\trelativeMatrix.copy( target.matrixWorld ).invert();\n\t\t\t\trelativeMatrix.multiply( boneTo.matrixWorld );\n\n\t\t\t}\n\n\t\t\t// ignore scale to extract rotation\n\n\t\t\tscale.setFromMatrixScale( relativeMatrix );\n\t\t\trelativeMatrix.scale( scale.set( 1 / scale.x, 1 / scale.y, 1 / scale.z ) );\n\n\t\t\t// apply to global matrix\n\n\t\t\tglobalMatrix.makeRotationFromQuaternion( quat.setFromRotationMatrix( relativeMatrix ) );\n\n\t\t\tif ( target.isObject3D ) {\n\n\t\t\t\tconst boneIndex = bones.indexOf( bone ),\n\t\t\t\t\twBindMatrix = bindBones ? bindBones[ boneIndex ] : bindBoneMatrix.copy( target.skeleton.boneInverses[ boneIndex ] ).invert();\n\n\t\t\t\tglobalMatrix.multiply( wBindMatrix );\n\n\t\t\t}\n\n\t\t\tglobalMatrix.copyPosition( relativeMatrix );\n\n\t\t}\n\n\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\tbone.matrix.multiply( globalMatrix );\n\n\t\t} else {\n\n\t\t\tbone.matrix.copy( globalMatrix );\n\n\t\t}\n\n\t\tif ( options.preserveHipPosition && name === options.hip ) {\n\n\t\t\tbone.matrix.setPosition( pos.set( 0, bone.position.y, 0 ) );\n\n\t\t}\n\n\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\tbone.updateMatrixWorld();\n\n\t}\n\n\tif ( options.preservePosition ) {\n\n\t\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\t\tbone = bones[ i ];\n\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\tif ( name !== options.hip ) {\n\n\t\t\t\tbone.position.copy( bonesPosition[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveMatrix ) {\n\n\t\t// restore matrix\n\n\t\ttarget.updateMatrixWorld( true );\n\n\t}\n\n}\n\nfunction retargetClip( target, source, clip, options = {} ) {\n\n\toptions.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n\toptions.fps = options.fps !== undefined ? options.fps : 30;\n\toptions.names = options.names || [];\n\n\tif ( ! source.isObject3D ) {\n\n\t\tsource = getHelperFromSkeleton( source );\n\n\t}\n\n\tconst numFrames = Math.round( clip.duration * ( options.fps / 1000 ) * 1000 ),\n\t\tdelta = 1 / options.fps,\n\t\tconvertedTracks = [],\n\t\tmixer = new AnimationMixer( source ),\n\t\tbones = getBones( target.skeleton ),\n\t\tboneDatas = [];\n\tlet positionOffset,\n\t\tbone, boneTo, boneData,\n\t\tname;\n\n\tmixer.clipAction( clip ).play();\n\tmixer.update( 0 );\n\n\tsource.updateMatrixWorld();\n\n\tfor ( let i = 0; i < numFrames; ++ i ) {\n\n\t\tconst time = i * delta;\n\n\t\tretarget( target, source, options );\n\n\t\tfor ( let j = 0; j < bones.length; ++ j ) {\n\n\t\t\tname = options.names[ bones[ j ].name ] || bones[ j ].name;\n\n\t\t\tboneTo = getBoneByName( name, source.skeleton );\n\n\t\t\tif ( boneTo ) {\n\n\t\t\t\tbone = bones[ j ];\n\t\t\t\tboneData = boneDatas[ j ] = boneDatas[ j ] || { bone: bone };\n\n\t\t\t\tif ( options.hip === name ) {\n\n\t\t\t\t\tif ( ! boneData.pos ) {\n\n\t\t\t\t\t\tboneData.pos = {\n\t\t\t\t\t\t\ttimes: new Float32Array( numFrames + 1 ),\n\t\t\t\t\t\t\tvalues: new Float32Array( ( numFrames + 1 ) * 3 )\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( options.useFirstFramePosition ) {\n\n\t\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\t\tpositionOffset = bone.position.clone();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbone.position.sub( positionOffset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.pos.times[ i ] = time;\n\n\t\t\t\t\tbone.position.toArray( boneData.pos.values, i * 3 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! boneData.quat ) {\n\n\t\t\t\t\t// `numFrames + 1` accomodate final keyframe\n\t\t\t\t\tboneData.quat = {\n\t\t\t\t\t\ttimes: new Float32Array( numFrames + 1 ),\n\t\t\t\t\t\tvalues: new Float32Array( ( numFrames + 1 ) * 4 )\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tboneData.quat.times[ i ] = time;\n\n\t\t\t\tbone.quaternion.toArray( boneData.quat.values, i * 4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check for final keyframe\n\t\tif ( i === numFrames - 1 ) {\n\n\t\t\tmixer.update( Math.max( clip.duration - mixer.time, 0 ) );\n\n\t\t} else {\n\n\t\t\tmixer.update( delta );\n\n\t\t}\n\n\t\tsource.updateMatrixWorld();\n\n\t}\n\n\tretarget( target, source, options );\n\n\t// add boneData at final keyframe\n\tfor ( let j = 0; j < boneDatas.length; ++ j ) {\n\n\t\tboneData = boneDatas[ j ];\n\n\t\tif ( boneData ) {\n\n\t\t\tif ( boneData.pos ) {\n\n\t\t\t\tboneData.pos.times[ numFrames ] = clip.duration;\n\n\t\t\t\tbone.position.toArray( boneData.pos.values, numFrames * 3 );\n\n\t\t\t}\n\n\t\t\tif ( boneData.quat ) {\n\n\t\t\t\tboneData.quat.times[ numFrames ] = clip.duration;\n\n\t\t\t\tbone.position.toArray( boneData.quat.values, numFrames * 4 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\tfor ( let i = 0; i < boneDatas.length; ++ i ) {\n\n\t\tboneData = boneDatas[ i ];\n\n\t\tif ( boneData ) {\n\n\t\t\tif ( boneData.pos ) {\n\n\t\t\t\tconvertedTracks.push( new VectorKeyframeTrack(\n\t\t\t\t\t'.bones[' + boneData.bone.name + '].position',\n\t\t\t\t\tboneData.pos.times,\n\t\t\t\t\tboneData.pos.values\n\t\t\t\t) );\n\n\t\t\t}\n\n\t\t\tconvertedTracks.push( new QuaternionKeyframeTrack(\n\t\t\t\t'.bones[' + boneData.bone.name + '].quaternion',\n\t\t\t\tboneData.quat.times,\n\t\t\t\tboneData.quat.values\n\t\t\t) );\n\n\t\t}\n\n\t}\n\n\tmixer.uncacheAction( clip );\n\n\treturn new AnimationClip( clip.name, - 1, convertedTracks );\n\n}\n\nfunction getHelperFromSkeleton( skeleton ) {\n\n\tconst source = new SkeletonHelper( skeleton.bones[ 0 ] );\n\tsource.skeleton = skeleton;\n\n\treturn source;\n\n}\n\nfunction getSkeletonOffsets( target, source, options = {} ) {\n\n\tconst targetParentPos = new Vector3(),\n\t\ttargetPos = new Vector3(),\n\t\tsourceParentPos = new Vector3(),\n\t\tsourcePos = new Vector3(),\n\t\ttargetDir = new Vector2(),\n\t\tsourceDir = new Vector2();\n\n\toptions.hip = options.hip !== undefined ? options.hip : 'hip';\n\toptions.names = options.names || {};\n\n\tif ( ! source.isObject3D ) {\n\n\t\tsource = getHelperFromSkeleton( source );\n\n\t}\n\n\tconst nameKeys = Object.keys( options.names ),\n\t\tnameValues = Object.values( options.names ),\n\t\tsourceBones = source.isObject3D ? source.skeleton.bones : getBones( source ),\n\t\tbones = target.isObject3D ? target.skeleton.bones : getBones( target ),\n\t\toffsets = [];\n\n\tlet bone, boneTo,\n\t\tname, i;\n\n\ttarget.skeleton.pose();\n\n\tfor ( i = 0; i < bones.length; ++ i ) {\n\n\t\tbone = bones[ i ];\n\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\tboneTo = getBoneByName( name, sourceBones );\n\n\t\tif ( boneTo && name !== options.hip ) {\n\n\t\t\tconst boneParent = getNearestBone( bone.parent, nameKeys ),\n\t\t\t\tboneToParent = getNearestBone( boneTo.parent, nameValues );\n\n\t\t\tboneParent.updateMatrixWorld();\n\t\t\tboneToParent.updateMatrixWorld();\n\n\t\t\ttargetParentPos.setFromMatrixPosition( boneParent.matrixWorld );\n\t\t\ttargetPos.setFromMatrixPosition( bone.matrixWorld );\n\n\t\t\tsourceParentPos.setFromMatrixPosition( boneToParent.matrixWorld );\n\t\t\tsourcePos.setFromMatrixPosition( boneTo.matrixWorld );\n\n\t\t\ttargetDir.subVectors(\n\t\t\t\tnew Vector2( targetPos.x, targetPos.y ),\n\t\t\t\tnew Vector2( targetParentPos.x, targetParentPos.y )\n\t\t\t).normalize();\n\n\t\t\tsourceDir.subVectors(\n\t\t\t\tnew Vector2( sourcePos.x, sourcePos.y ),\n\t\t\t\tnew Vector2( sourceParentPos.x, sourceParentPos.y )\n\t\t\t).normalize();\n\n\t\t\tconst laterialAngle = targetDir.angle() - sourceDir.angle();\n\n\t\t\tconst offset = new Matrix4().makeRotationFromEuler(\n\t\t\t\tnew Euler(\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tlaterialAngle\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tbone.matrix.multiply( offset );\n\n\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\tbone.updateMatrixWorld();\n\n\t\t\toffsets[ name ] = offset;\n\n\t\t}\n\n\t}\n\n\treturn offsets;\n\n}\n\nfunction renameBones( skeleton, names ) {\n\n\tconst bones = getBones( skeleton );\n\n\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\tconst bone = bones[ i ];\n\n\t\tif ( names[ bone.name ] ) {\n\n\t\t\tbone.name = names[ bone.name ];\n\n\t\t}\n\n\t}\n\n\treturn this;\n\n}\n\nfunction getBones( skeleton ) {\n\n\treturn Array.isArray( skeleton ) ? skeleton : skeleton.bones;\n\n}\n\nfunction getBoneByName( name, skeleton ) {\n\n\tfor ( let i = 0, bones = getBones( skeleton ); i < bones.length; i ++ ) {\n\n\t\tif ( name === bones[ i ].name )\n\n\t\t\treturn bones[ i ];\n\n\t}\n\n}\n\nfunction getNearestBone( bone, names ) {\n\n\twhile ( bone.isBone ) {\n\n\t\tif ( names.indexOf( bone.name ) !== - 1 ) {\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t\tbone = bone.parent;\n\n\t}\n\n}\n\nfunction findBoneTrackData( name, tracks ) {\n\n\tconst regexp = /\\[(.*)\\]\\.(.*)/,\n\t\tresult = { name: name };\n\n\tfor ( let i = 0; i < tracks.length; ++ i ) {\n\n\t\t// 1 is track name\n\t\t// 2 is track type\n\t\tconst trackData = regexp.exec( tracks[ i ].name );\n\n\t\tif ( trackData && name === trackData[ 1 ] ) {\n\n\t\t\tresult[ trackData[ 2 ] ] = i;\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\nfunction getEqualsBonesNames( skeleton, targetSkeleton ) {\n\n\tconst sourceBones = getBones( skeleton ),\n\t\ttargetBones = getBones( targetSkeleton ),\n\t\tbones = [];\n\n\tsearch : for ( let i = 0; i < sourceBones.length; i ++ ) {\n\n\t\tconst boneName = sourceBones[ i ].name;\n\n\t\tfor ( let j = 0; j < targetBones.length; j ++ ) {\n\n\t\t\tif ( boneName === targetBones[ j ].name ) {\n\n\t\t\t\tbones.push( boneName );\n\n\t\t\t\tcontinue search;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn bones;\n\n}\n\nfunction clone( source ) {\n\n\tconst sourceLookup = new Map();\n\tconst cloneLookup = new Map();\n\n\tconst clone = source.clone();\n\n\tparallelTraverse( source, clone, function ( sourceNode, clonedNode ) {\n\n\t\tsourceLookup.set( clonedNode, sourceNode );\n\t\tcloneLookup.set( sourceNode, clonedNode );\n\n\t} );\n\n\tclone.traverse( function ( node ) {\n\n\t\tif ( ! node.isSkinnedMesh ) return;\n\n\t\tconst clonedMesh = node;\n\t\tconst sourceMesh = sourceLookup.get( node );\n\t\tconst sourceBones = sourceMesh.skeleton.bones;\n\n\t\tclonedMesh.skeleton = sourceMesh.skeleton.clone();\n\t\tclonedMesh.bindMatrix.copy( sourceMesh.bindMatrix );\n\n\t\tclonedMesh.skeleton.bones = sourceBones.map( function ( bone ) {\n\n\t\t\treturn cloneLookup.get( bone );\n\n\t\t} );\n\n\t\tclonedMesh.bind( clonedMesh.skeleton, clonedMesh.bindMatrix );\n\n\t} );\n\n\treturn clone;\n\n}\n\n\n\n\nfunction parallelTraverse( a, b, callback ) {\n\n\tcallback( a, b );\n\n\tfor ( let i = 0; i < a.children.length; i ++ ) {\n\n\t\tparallelTraverse( a.children[ i ], b.children[ i ], callback );\n\n\t}\n\n}\n\nexport {\n\tretarget,\n\tretargetClip,\n\tgetHelperFromSkeleton,\n\tgetSkeletonOffsets,\n\trenameBones,\n\tgetBones,\n\tgetBoneByName,\n\tgetNearestBone,\n\tfindBoneTrackData,\n\tgetEqualsBonesNames,\n\tclone,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}